# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from common_msgs/VehicleDebug.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class VehicleDebug(genpy.Message):
  _md5sum = "d52e92640147378e42db3b692c081abe"
  _type = "common_msgs/VehicleDebug"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header header
# 蠕行
int16    flag_crawl
float64 crawl_speed_error               # 蠕行速度误差
float64 crawl_veh_accel                 # 蠕行加速度指令
float64 crawl_acc_pel                   # 油门踏板开度
float64 crawl_brk_pel                   # 制动踏板开度

# 纵向控制
# 位置pid
float64 s_matched                       # 匹配点s  
float64 station_preview                 # 预瞄点s     
float64 station_error                   # 预瞄点位置误差      
float64 station_error_limited           # 限幅后的纵向位置误差
float64 speed_offset                    # 位置pid得到的速度补偿
# 速度pid
float64 speed_preview                   # 预瞄点参考车速
float64 speed_matched                   # 匹配点车速
float64 preview_speed_error             # 预瞄点速度误差   
float64 speed_controller_input_limited  # 限幅后的纵向速度误差
float64 acceleration_cmd_closeloop      # 速度pid得到的加速度补偿
# 加速度
float64 path_remain                     # 距离停车点的距离
float64 acceleration_lookup             # 纵向控制计算出用于查表的加速度
float64 throttle_cmd                    # 查表得到的油门开度
float64 brake_cmd                       # 查表得到的制动踏板开度

# 横向控制    
int16   lat_target_pointIdx             # 目标点索引序号
float64 lat_target_x                    # 目标点x
float64 lat_target_y                    # 目标点x
float64 cmd_strangle                    # 方向盘转角指令
float64 heading_error                   # 用于方向盘转角补偿的航向角误差

# 状态相关标志位
int16   mode                            # 当前驾驶模式：1（AEB）,2（Terminal_stop），3（Gear_wrong），4（Msg_lost），5（Crawl），6（Normal）
int16   idx_trajectory_local_set        # 局部轨迹集合索引序号
int16    flag_replan                     # 重规划标志位
float64 cur_gear                        # 当前档位:1P2R3N4D
float64 tar_gear                        # 目标档位
int16    trajectory_flag                 # 轨迹正常标志位
int16    loc_flag                        # 定位正常标志位
int16[] start_indices                   # 存储每段轨迹的起始索引  
int16[] end_indices                     # 存储每段轨迹的结束索引 
float64 dist2terminal                   # 到终点的距离
int16    flag_terminal                   # 终点停车标志位


================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id
"""
  __slots__ = ['header','flag_crawl','crawl_speed_error','crawl_veh_accel','crawl_acc_pel','crawl_brk_pel','s_matched','station_preview','station_error','station_error_limited','speed_offset','speed_preview','speed_matched','preview_speed_error','speed_controller_input_limited','acceleration_cmd_closeloop','path_remain','acceleration_lookup','throttle_cmd','brake_cmd','lat_target_pointIdx','lat_target_x','lat_target_y','cmd_strangle','heading_error','mode','idx_trajectory_local_set','flag_replan','cur_gear','tar_gear','trajectory_flag','loc_flag','start_indices','end_indices','dist2terminal','flag_terminal']
  _slot_types = ['std_msgs/Header','int16','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','int16','float64','float64','float64','float64','int16','int16','int16','float64','float64','int16','int16','int16[]','int16[]','float64','int16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,flag_crawl,crawl_speed_error,crawl_veh_accel,crawl_acc_pel,crawl_brk_pel,s_matched,station_preview,station_error,station_error_limited,speed_offset,speed_preview,speed_matched,preview_speed_error,speed_controller_input_limited,acceleration_cmd_closeloop,path_remain,acceleration_lookup,throttle_cmd,brake_cmd,lat_target_pointIdx,lat_target_x,lat_target_y,cmd_strangle,heading_error,mode,idx_trajectory_local_set,flag_replan,cur_gear,tar_gear,trajectory_flag,loc_flag,start_indices,end_indices,dist2terminal,flag_terminal

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(VehicleDebug, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.flag_crawl is None:
        self.flag_crawl = 0
      if self.crawl_speed_error is None:
        self.crawl_speed_error = 0.
      if self.crawl_veh_accel is None:
        self.crawl_veh_accel = 0.
      if self.crawl_acc_pel is None:
        self.crawl_acc_pel = 0.
      if self.crawl_brk_pel is None:
        self.crawl_brk_pel = 0.
      if self.s_matched is None:
        self.s_matched = 0.
      if self.station_preview is None:
        self.station_preview = 0.
      if self.station_error is None:
        self.station_error = 0.
      if self.station_error_limited is None:
        self.station_error_limited = 0.
      if self.speed_offset is None:
        self.speed_offset = 0.
      if self.speed_preview is None:
        self.speed_preview = 0.
      if self.speed_matched is None:
        self.speed_matched = 0.
      if self.preview_speed_error is None:
        self.preview_speed_error = 0.
      if self.speed_controller_input_limited is None:
        self.speed_controller_input_limited = 0.
      if self.acceleration_cmd_closeloop is None:
        self.acceleration_cmd_closeloop = 0.
      if self.path_remain is None:
        self.path_remain = 0.
      if self.acceleration_lookup is None:
        self.acceleration_lookup = 0.
      if self.throttle_cmd is None:
        self.throttle_cmd = 0.
      if self.brake_cmd is None:
        self.brake_cmd = 0.
      if self.lat_target_pointIdx is None:
        self.lat_target_pointIdx = 0
      if self.lat_target_x is None:
        self.lat_target_x = 0.
      if self.lat_target_y is None:
        self.lat_target_y = 0.
      if self.cmd_strangle is None:
        self.cmd_strangle = 0.
      if self.heading_error is None:
        self.heading_error = 0.
      if self.mode is None:
        self.mode = 0
      if self.idx_trajectory_local_set is None:
        self.idx_trajectory_local_set = 0
      if self.flag_replan is None:
        self.flag_replan = 0
      if self.cur_gear is None:
        self.cur_gear = 0.
      if self.tar_gear is None:
        self.tar_gear = 0.
      if self.trajectory_flag is None:
        self.trajectory_flag = 0
      if self.loc_flag is None:
        self.loc_flag = 0
      if self.start_indices is None:
        self.start_indices = []
      if self.end_indices is None:
        self.end_indices = []
      if self.dist2terminal is None:
        self.dist2terminal = 0.
      if self.flag_terminal is None:
        self.flag_terminal = 0
    else:
      self.header = std_msgs.msg.Header()
      self.flag_crawl = 0
      self.crawl_speed_error = 0.
      self.crawl_veh_accel = 0.
      self.crawl_acc_pel = 0.
      self.crawl_brk_pel = 0.
      self.s_matched = 0.
      self.station_preview = 0.
      self.station_error = 0.
      self.station_error_limited = 0.
      self.speed_offset = 0.
      self.speed_preview = 0.
      self.speed_matched = 0.
      self.preview_speed_error = 0.
      self.speed_controller_input_limited = 0.
      self.acceleration_cmd_closeloop = 0.
      self.path_remain = 0.
      self.acceleration_lookup = 0.
      self.throttle_cmd = 0.
      self.brake_cmd = 0.
      self.lat_target_pointIdx = 0
      self.lat_target_x = 0.
      self.lat_target_y = 0.
      self.cmd_strangle = 0.
      self.heading_error = 0.
      self.mode = 0
      self.idx_trajectory_local_set = 0
      self.flag_replan = 0
      self.cur_gear = 0.
      self.tar_gear = 0.
      self.trajectory_flag = 0
      self.loc_flag = 0
      self.start_indices = []
      self.end_indices = []
      self.dist2terminal = 0.
      self.flag_terminal = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_h18dh4d3h2d2h().pack(_x.flag_crawl, _x.crawl_speed_error, _x.crawl_veh_accel, _x.crawl_acc_pel, _x.crawl_brk_pel, _x.s_matched, _x.station_preview, _x.station_error, _x.station_error_limited, _x.speed_offset, _x.speed_preview, _x.speed_matched, _x.preview_speed_error, _x.speed_controller_input_limited, _x.acceleration_cmd_closeloop, _x.path_remain, _x.acceleration_lookup, _x.throttle_cmd, _x.brake_cmd, _x.lat_target_pointIdx, _x.lat_target_x, _x.lat_target_y, _x.cmd_strangle, _x.heading_error, _x.mode, _x.idx_trajectory_local_set, _x.flag_replan, _x.cur_gear, _x.tar_gear, _x.trajectory_flag, _x.loc_flag))
      length = len(self.start_indices)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(struct.Struct(pattern).pack(*self.start_indices))
      length = len(self.end_indices)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(struct.Struct(pattern).pack(*self.end_indices))
      _x = self
      buff.write(_get_struct_dh().pack(_x.dist2terminal, _x.flag_terminal))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 206
      (_x.flag_crawl, _x.crawl_speed_error, _x.crawl_veh_accel, _x.crawl_acc_pel, _x.crawl_brk_pel, _x.s_matched, _x.station_preview, _x.station_error, _x.station_error_limited, _x.speed_offset, _x.speed_preview, _x.speed_matched, _x.preview_speed_error, _x.speed_controller_input_limited, _x.acceleration_cmd_closeloop, _x.path_remain, _x.acceleration_lookup, _x.throttle_cmd, _x.brake_cmd, _x.lat_target_pointIdx, _x.lat_target_x, _x.lat_target_y, _x.cmd_strangle, _x.heading_error, _x.mode, _x.idx_trajectory_local_set, _x.flag_replan, _x.cur_gear, _x.tar_gear, _x.trajectory_flag, _x.loc_flag,) = _get_struct_h18dh4d3h2d2h().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.start_indices = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.end_indices = s.unpack(str[start:end])
      _x = self
      start = end
      end += 10
      (_x.dist2terminal, _x.flag_terminal,) = _get_struct_dh().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_h18dh4d3h2d2h().pack(_x.flag_crawl, _x.crawl_speed_error, _x.crawl_veh_accel, _x.crawl_acc_pel, _x.crawl_brk_pel, _x.s_matched, _x.station_preview, _x.station_error, _x.station_error_limited, _x.speed_offset, _x.speed_preview, _x.speed_matched, _x.preview_speed_error, _x.speed_controller_input_limited, _x.acceleration_cmd_closeloop, _x.path_remain, _x.acceleration_lookup, _x.throttle_cmd, _x.brake_cmd, _x.lat_target_pointIdx, _x.lat_target_x, _x.lat_target_y, _x.cmd_strangle, _x.heading_error, _x.mode, _x.idx_trajectory_local_set, _x.flag_replan, _x.cur_gear, _x.tar_gear, _x.trajectory_flag, _x.loc_flag))
      length = len(self.start_indices)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(self.start_indices.tostring())
      length = len(self.end_indices)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(self.end_indices.tostring())
      _x = self
      buff.write(_get_struct_dh().pack(_x.dist2terminal, _x.flag_terminal))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 206
      (_x.flag_crawl, _x.crawl_speed_error, _x.crawl_veh_accel, _x.crawl_acc_pel, _x.crawl_brk_pel, _x.s_matched, _x.station_preview, _x.station_error, _x.station_error_limited, _x.speed_offset, _x.speed_preview, _x.speed_matched, _x.preview_speed_error, _x.speed_controller_input_limited, _x.acceleration_cmd_closeloop, _x.path_remain, _x.acceleration_lookup, _x.throttle_cmd, _x.brake_cmd, _x.lat_target_pointIdx, _x.lat_target_x, _x.lat_target_y, _x.cmd_strangle, _x.heading_error, _x.mode, _x.idx_trajectory_local_set, _x.flag_replan, _x.cur_gear, _x.tar_gear, _x.trajectory_flag, _x.loc_flag,) = _get_struct_h18dh4d3h2d2h().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.start_indices = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.end_indices = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
      _x = self
      start = end
      end += 10
      (_x.dist2terminal, _x.flag_terminal,) = _get_struct_dh().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_dh = None
def _get_struct_dh():
    global _struct_dh
    if _struct_dh is None:
        _struct_dh = struct.Struct("<dh")
    return _struct_dh
_struct_h18dh4d3h2d2h = None
def _get_struct_h18dh4d3h2d2h():
    global _struct_h18dh4d3h2d2h
    if _struct_h18dh4d3h2d2h is None:
        _struct_h18dh4d3h2d2h = struct.Struct("<h18dh4d3h2d2h")
    return _struct_h18dh4d3h2d2h
